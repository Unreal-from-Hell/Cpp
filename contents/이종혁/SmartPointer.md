# 스마트 포인터 (Smart Pointer)
> 포인터 처럼 사용하는 클래스 템플릿으로 메모리를 자동으로 해제해준다

 * C++11 이후 메모리 누수(memory leak)로 부터 프로그램의 안정성을 보장하기 위해 등장했다

 <br>

 ### ***포인터를 그대로 사용하는 방식은 위험하기 때문에 Modern C++에서 지양한다***

 <br>

### 스마트 포인터의 동작

<br>

1. new 키워드를 사용해 기본 포인터(raw pointer)가 실제 메모리를 가리키도록 초기화한 후에 기본 포인터를 스마트 포인터에 대입하여 사용한다
2. 이렇게 정의된 스마트 포인터의 수명이 다하면 소멸자는 delete 키워드를 사용하여 할당된 메모리를 자동으로 해제한다

<br>

### ***따라서 new 키워드가 반환하는 주소 값을 스마트 포인터에 대입하면 메모리를 따로 해제할 필요가 없어진다***

<br>

### 스마트 포인터는 3가지 종류가 있다
1. shared_ptr
2. weak_ptr
3. unique_ptr

<br>

### ***스마트 포인터는 memory 헤더 파일에 정의되어 있다***

---
<br>

## Shared_ptr
> 하나의 특정 객체를 참조하는 스마트 포인터가 총 몇 개인지를 참조하는 스마트 포인터

 * 참조하고 있는 스마트 포인터의 개수를 `참조 횟수`라고 한다
 * 참조 횟수는 특정 객체에 shared_ptr이 추가될 때 마다 1씩 증가하고 소멸될 때마다 1씩 감소한다
 * 참조 횟수가 0이 되면 delete 키워드를 사용하여 메모리를 자동으로 해제한다

<br>

### shared_ptr 의 사용
> make_shared<TYPE>() 함수를 이용하여 인스턴스를 생성할 수 있다

<br>

``` cpp
shared_ptr<Knight> sptr = make_shared<Knight>();

sptr.use_count();     // 참조 횟수를 반환하는 함수
sptr.reset();         // shared_ptr 해제
```

### ***서로가 상대방을 참조하게 되면 순환 참조가 발생한다***
> 순환 참조가 발생하면 참조 횟수는 절대 0이 되지 않으므로 메모리는 영원히 해제되지 않는다

---
<br>

## Weak_ptr
> 하나 이상의 shared_ptr 인스턴스가 소유하는 객체에 대한 접근을 제공하지만 소유자의 수에는 포함되지 않는 스마트 포인터

 * shared_ptr의 순환 참조를 제거하기 위해 사용된다

<br>

### weak_ptr 의 사용
> waek_unique<TYPE>() 함수를 이용하여 인스턴스를 생성할 수 있다

<br>

``` cpp
weak_ptr<Knight> wptr;

if(target.expired() == false)       // 포인터가 유효한지 검사
{
    // 유효하다면 lock() 함수를 사용해 shared_ptr로 반환하여 사용
    shared_ptr<Knight> sptr = wptr.lock();
}
```
 * 생명주기에서 자유로워지기 때문에 순환구조를 방지할 수 있다

---
<br>

## Unique_ptr
> 하나의 스마트 포인터만이 특정 개체를 소유할 수 있도록 객체에 소유권 개념을 도입한 스마트 포인터

 * 해당 객체의 소유권을 가지고 있을 때만 소멸자가 해당 객체를 삭제할 수 있다
 * unique_ptr 인스턴스는 복사가 불가능하고 move() 함수를 통해 소유권을 이전할 수 있다
 * 소유권이 이전되면 이전 인스턴스는 해당 객체를 더이상 소유하지 않는다

<br>

### unique_ptr 의 사용
> make_unique<TYPE>() 함수를 이용하여 인스턴스를 생성할 수 있다

``` cpp
unique_ptr<Knight> uptr = make_unique<Knight>();
```

 * 해당 함수를 사용하면 예외 발생에 대해 안전하게 대처할 수 있다